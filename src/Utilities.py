###########################################################################
#   This is part of the module phystricks
#
#   phystricks is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   phystricks is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with phystricks.py.  If not, see <http://www.gnu.org/licenses/>.
###########################################################################

# copyright (c) Laurent Claessens, 2010-2017, 2019
# email: laurent@claessens-donadello.eu

from sage.all import SR, sqrt, numerical_approx, arctan, var, solve, atan
from sage.rings.real_mpfr import RealNumber

from phystricks.src.Decorators import sort_and_assert_real
from phystricks.src.Numerical import numerical_is_negative
from phystricks.src.Exceptions import ShouldNotHappenException
from phystricks.src.degree_unit import degree


def add_latex_line_entete(truc, position=""):
    if not position:
        position = truc.entete_position
    truc.add_latex_line(
        "% This file is automatically generated by phystricks", position)
    truc.add_latex_line("% See the documentation ", position)
    truc.add_latex_line(
        "% http://student.ulb.ac.be/~lclaesse/phystricks-doc.pdf ", position)
    truc.add_latex_line(
        "% http://student.ulb.ac.be/~lclaesse/phystricks-documentation/_build/html/index.html ", position)
    truc.add_latex_line(
        "% and the projects phystricks and phystricks-doc at ", position)
    truc.add_latex_line(
        "% https://github.com/LaurentClaessens/phystricks", position)


def is_real(z):
    if type(z) in [int, RealNumber]:
        return True
    return z.is_real()


def test_imaginary_part(z, epsilon=0.0001):
    """
    Return a tuple '(isreal,w)' where 'isreal' is a boolean saying if 'z' is real (in the sense that it is real and does not contain 'I' in its string representation) and 'w' is 'z' when the imaginary part is larger than epsilon and an 'numerical_approx' of 'z' when its imaginary part is smaller than 'epsilon'

    With the collateral effect that it returns a numerical approximation.
    """
    if is_real(z) and "I" not in str(z):
        return True, z
    k = numerical_approx(z)
    if is_real(k):
        return True, k
    if abs(k.imag_part()) < epsilon:
        return True, numerical_approx(z.real_part())
    print("It seems that an imaginary part is not so small.")
    return False, z


def test_imaginary_part_point(P, epsilon=0.0001):
    """
    return the tuple '(isreal,P)' whit the same description of 'test_imaginary_part'
    """
    from Constructors import Point
    realx, x = test_imaginary_part(P.x)
    realy, y = test_imaginary_part(P.y)
    on = False
    if realx and realy:
        on = True
    return on, Point(x, y)

# return the squared distance between P and Q
#
# \param numerical If True, use numerical approximations and return
# a numerical approximation.


def distance_sq(P, Q, numerical=False):
    if not numerical:
        return (P.x-Q.x)**2+(P.y-Q.y)**2
    Px = numerical_approx(P.x)
    Qx = numerical_approx(Q.x)
    Qy = numerical_approx(Q.y)
    Py = numerical_approx(P.y)
    return (Px-Qx)**2+(Py-Qy)**2


def distance(P, Q):
    """ return the distance between P and Q """
    return sqrt(distance_sq(P, Q))

# \brief  Return the inner product of vectors `v` and `w`
# \param v a vector
# \param w a vector
# \param numerical a boolean
#
# If `numerical` is true, the computations are done on
# numerical approximations of the coordinates.


def inner_product(v, w, numerical=False):
    from PointGraph import PointGraph
    from Constructors import Point
    from AffineVectorGraph import AffineVectorGraph

    if numerical:
        if not v.I.is_almost_equal(w.I):
            raise OperationNotPermitedException("I only compute inner products\
                    of vectors based on the same point.")
    if not numerical:
        if v.I != w.I:
            raise OperationNotPermitedException("I only compute inner products\
                    of vectors based on the same point.")

    s = v.Dx*w.Dx+v.Dy*w.Dy
    if numerical:
        return numerical_approx(s)
    return s


@sort_and_assert_real
def Intersection(f, g, a=None, b=None, numerical=False):
    ##
    # When f and g are objects with an attribute equation, return the list of points of intersections.
    #
    # - The list of point is sorted by order of `x` coordinates.
    # - Return only real solutions.
    #
    # Only numerical approximations are returned as there are some errors
    # otherwise. As an example the following #solving return points that
    # are not even near from the circle \f$ x^2+y^2=9 \f$ :
    # ```
    # solve( [ -1/3*sqrt(3)*y + 1/3*sqrt(3)*(-0.19245008972987399*sqrt(3) - 3) + x == 0,x^2 + y^2 - 9 == 0 ],[x,y] )
    # ```
    #
    # ## Examples
    #
    # ```
    #    sage: from phystricks import *
    #    sage: fun=phyFunction(x**2-5*x+6)
    #    sage: droite=phyFunction(2)
    #    sage: pts = Intersection(fun,droite)
    #    sage: for P in pts:print P
    #    <Point(1,2)>
    #    <Point(4,2)>
    #```
    #
    #```
    #    sage: f=phyFunction(sin(x))
    #    sage: g=phyFunction(cos(x))
    #    sage: pts=Intersection(f,g,-2*pi,2*pi,numerical=True)
    #    sage: for P in pts:print P
    #    <Point(-5.497787143782138,0.707106781186548)>
    #    <Point(-2.3561944901923466,-0.707106781186546)>
    #    <Point(0.7853981633974484,0.707106781186548)>
    #    <Point(3.926990816987241,-0.707106781186547)>
    #```
    #
    #  If 'numerical' is True, it search for the intersection points of the functions 'f' and 'g' (it only work with functions). In this case an interval is required.

    from AffineVectorGraph import AffineVectorGraph

    if isinstance(f, AffineVectorGraph):
        f = f.segment
    if isinstance(g, AffineVectorGraph):
        g = g.segment

    if numerical and "sage" in dir(f):
        import SmallComputations
        k = f-g
        xx = SmallComputations.find_roots_recursive(k.sage, a, b)
        pts = [Point(x, f(x)) for x in xx]
        return pts

    x, y = var('x,y')
    pts = []
    if numerical:
        soluce = solve([f.equation(numerical=True),
                        g.equation(numerical=True)], [x, y])
    else:
        soluce = solve([f.equation(), g.equation()], [x, y])
    for s in soluce:
        a = s[0].rhs()
        b = s[1].rhs()
        z = a**2+b**2
        ok1, a = test_imaginary_part(a)
        ok2, b = test_imaginary_part(b)
        if ok1 and ok2:
            pts.append(Point(a, b))
    return pts

# \brief The intersection between the line from the given point and
# the center of the given box.
#
# \arg P : a point
# \arg box : a box, which means a duck which has attributes
#               `xmin`, `xmax`, `ymin`, `ymax`
#
# Consider the line from `P` to the center of the box
# and return the intersection
# points.
#
# \return a list of `Point`.
#
# - The list always contains exactly 2 points
# - They are sorted by order of distance to `P`


def point_to_box_intersection(P, box, pspict=None):
    from phystricks.src.Utilities import distance_sq
    A = Point(box.xmin, box.ymin)
    B = Point(box.xmax, box.ymin)
    C = Point(box.xmax, box.ymax)
    D = Point(box.xmin, box.ymax)
    # n'écrivez pas ça au tableau quand un inspecteur est dans la salle :
    center = (A+B+C+D)/4
    line = Segment(P, center)

    edges = [Segment(A, B), Segment(B, C), Segment(C, D), Segment(D, A)]
    inter = []
    for ed in edges:
        c = Intersection(line, ed)
        if len(c) > 0:
            S = c[0]

            # We deal with the case in which the line travers the corner.
            # In this case, the line passes trough the other one.
            if S == A:
                inter = [A, C]
            if S == B:
                inter = [B, D]
            if S == C:
                inter = [A, C]
            if S == D:
                inter = [B, D]
            # The last two tests are to know if S lies between ed.I and ed.F
            # We use numerical approximations in order to avoid some
            # OverflowError: Python int too large to convert to C long
            elif numerical_approx((S.x-ed.I.x)*(S.x-ed.F.x)) < 0:
                inter.append(S)
            elif numerical_approx((S.y-ed.I.y)*(S.y-ed.F.y)) < 0:
                inter.append(S)

    if len(inter) == 2:
        inter.sort(key=lambda Q: distance_sq(Q, P, numerical=True))

    if pspict:
        for i, S in enumerate(inter):
            S.put_mark(0.2, angle=None, added_angle=0,
                       text=str(i), pspict=pspict)
        pspict.DrawGraphs(inter, line, center, box)

    return inter




def EnsurephyFunction(f):
    from Constructors import phyFunction
    try:
        k = phyFunction(f.sage)
    except AttributeError:
        pass
    try:
        k = f.phyFunction()
    except AttributeError:
        pass
    k = phyFunction(f)
    try:
        k.nul_function = f.nul_function
    except AttributeError:
        pass
    return k


def EnsureParametricCurve(curve):
    if "parametric_curve" in dir(curve):
        return curve.parametric_curve()
    else:
        return curve


def check_too_large(obj, pspict=None):
    try:
        bb = obj.bounding_box(pspict)
        mx = bb.xmin
        my = bb.ymin
        Mx = bb.xmax
        My = bb.ymax

    except AttributeError:
        print("Object {0} has no method bounding_box.".format(obj))
        mx = obj.mx
        my = obj.my
        Mx = obj.Mx
        My = obj.My
    if pspict:
        from Exceptions import TooLargeBBException
        # In some circumstances, the comparison
        # mx<pspict.mx_acceptable_BB
        # provokes a MemoryError.
        n_Mx = numerical_approx(Mx)
        n_mx = numerical_approx(mx)
        n_My = numerical_approx(My)
        n_my = numerical_approx(my)
        if n_mx < pspict.mx_acceptable_BB:
            raise TooLargeBBException(
                obj=obj, faulty="xmin", acceptable=pspict.mx_acceptable_BB, got=n_mx)
        if n_my < pspict.my_acceptable_BB:
            raise TooLargeBBException(
                obj=obj, faulty="ymin", acceptable=pspict.my_acceptable_BB, got=n_my)
        if n_Mx > pspict.Mx_acceptable_BB:
            raise TooLargeBBException(
                obj=obj, faulty="xmax", acceptable=pspict.Mx_acceptable_BB, got=n_Mx)
        if n_My > pspict.My_acceptable_BB:
            raise TooLargeBBException(
                obj=obj, faulty="ymax", acceptable=pspict.My_acceptable_BB, got=n_My)


def general_function_get_point(fun, x, advised=True):
    """
    Return a point on the graph of the function with the given x, i.e. it return the point (x,f(x)).

    Also set an attribute advised_mark_angle to the point. This angle is the normal exterior to the graph; visually this is usually the best place to put a mark. Typically you use this as
    P=f.get_point(3)
    P.mark(radius,P.advised_mark_angle,"$P$")

    NOTE:
    If you don't plan to put a mark on the point, you are invited
    to use advised=False in order to speed up the computations.
    """
    P = Point(float(x), fun(x))
    if advised:
        try:
            ca = fun.derivative()(x)
        except TypeError:    # Sage cannot derivate the function
            print("I'm not able to compute derivative of {0}.\
            You should pass advised=False".format(fun))
        else:
            angle_n = degree(atan(ca)+pi/2)
            if fun.derivative(2)(x) > 0:
                angle_n = angle_n+180
            P._advised_mark_angle = angle_n
    return P


def latinize(word):
    """
    return a "latinized" version of a string.

    From a string, return something that can be used as point name, file name.
    In particular, remove the special characters, put everything in lowercase,
    and turn the numbers into letters.

    This function is used in order to turn the script name into a
    string that can be a filename for the LaTeX's intermediate file.

    INPUT:

    - ``word`` - string

    OUTPUT:
    string

    EXAMPLES::

        sage: from phystricks.SmallComputations import *
        sage: latinize("/home/MyName/.sage/my_script11.py")
        'homeMyNameDsagemyscriptOODpy'

    ::

        sage: from phystricks.SmallComputations import *
        sage: latinize("/home/MyName/.sage/my_script13.py")
        'homeMyNameDsagemyscriptOThDpy'
    """
    latin = ""
    for s in word:
        if s.lower() in "abcdefghijklmnopqrstuvwxyz":
            latin = latin+s
        if s == "1":
            latin = latin+"ONE"
        if s == "2":
            latin = latin+"TWO"
        if s == "3":
            latin = latin+"THREE"
        if s == "4":
            latin = latin+"FOR"
        if s == "5":
            latin = latin+"FIVE"
        if s == "6":
            latin = latin+"SIX"
        if s == "7":
            latin = latin+"SEVEN"
        if s == "8":
            latin = latin+"HEITH"
        if s == "9":
            latin = latin+"NINE"
        if s == "0":
            latin = latin+"ZERO"
        if s == ".":
            latin = latin+"DOT"
    return latin


def counterName():
    r"""
    This function provides the name of the counter.

    This has the same use of newwriteName, for the same reason of limitation.
    """
    return "counterOfforphystricks"


def newlengthName():
    r"""
    This function provides the name of the length.

    This has the same use of newwriteName, for the same reason of limitation.
    """
    return "lengthOfforphystricks"


def sublist(l, condition):
    """
    Extract a sublist of 'l' made of the elements that satisfy the condition.

    Do not return a new list, but is an iterator.
    """
    for x in l:
        if condition(x):
            yield x


def make_psp_list(pspict, pspicts):
    if isinstance(pspict, list):
        raise
    a = []
    if pspict is not None:
        a.append(pspict)
    if pspicts is not None:
        a.extend(pspicts)
    if a == []:
        raise ShouldNotHappenException(
            "Picture missing. You have to use at least one of 'pspict=...' or 'pspicts=[...]'")
    return a


def no_symbol(*arg):
    for l in arg:
        try:
            for P in l:
                no_symbol(P)
        except TypeError:
            l.parameters.symbol = ""


def get_equal_lengths_code(s1, s2, n=1, d=0.1, l=0.1, angle=45, pspict=None, pspicts=None):
    from ObjectGraph import AddedObjects
    from phystricks.src.Utilities import make_psp_list
    added1 = AddedObjects()
    added2 = AddedObjects()
    pspicts = make_psp_list(pspict, pspicts)
    for psp in pspicts:
        c1 = s1.get_code(n=n, d=d, l=l, pspict=psp)
        c2 = s2.get_code(n=n, d=d, l=l, pspict=psp)
        added1.append(psp, c1)
        added2.append(psp, c2)
    return added1, added2


def put_equal_lengths_code(s1, s2, n=1, d=0.1, l=0.1, angle=45, pspict=None, pspicts=None):
    """
    Add the code for equal length between segments s1 and s2
    """
    from phystricks.src.Utilities import make_psp_list
    pspicts = make_psp_list(pspict, pspicts)
    for psp in pspicts:
        added = get_equal_lengths_code(s1, s2, n, d, l, angle, pspict=psp)
        c1 = added[0]
        c2 = added[1]
        s1.added_objects.fusion(c1)
        s2.added_objects.fusion(c2)

# \brief turn the given number into a string with some conversion
#  and approximations rules.
#
# When one coordinate if very small (lower than 0.0001), it
# is rounded to zero in order to avoid string like "0.2335e-6"
# in the pstricks code.
#
# The parameter `digit` is *not* the same as the one in
# Sage's `numerical_approx`.
# Here we compute a numerical approximation (the one of sage) and then we cut
# the resulting *string* to the desired numbers of digits.
# The rounding is thus not always the expected one.
# The reason is this kind of expression :
#    ```
#    a=7.73542889062775*cos(11/9*pi + 1.30951587282752) - 7.55775391156456*cos(5/18*pi) + 2.5*cos(2/9*pi)
#    print(numerical_approx(a))
#    print(numerical_approx(a,digits=5))
#   ```
# The first print is deterministic (0.329851686365047), while the second
# one is not.
#
# Remark : undefined behaviour is the integer part of `x` requires more
# digits than `digits`.


def number_to_string(x, digits):
    from Numerical import is_almost_zero
    nx = numerical_approx(x)

    # Avoid something like "0.125547e-6" (LaTeX will not accept).
    if is_almost_zero(nx, 0.001):
        if digits == 1:
            return "0"
        return "0."+"0"*(digits-1)

    sx = str(nx)

    # in a definitive release, this test can be removed.
    # this is only for my culture; I guess that it never happens
    if "." not in sx:
        print(x)
        print(sx)
        raise

    sx = sx+"0"*(digits+1)  # be sure not to lack digits
    if nx < 0:
        sx = sx[0:digits+2]    # +1 for the decimal dot, +1 for the minus
    else:
        sx = sx[0:digits+1]
    if sx.endswith("."):
        sx = sx[:-1]

    return sx
